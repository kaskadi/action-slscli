{"version":3,"sources":["../../lib/dev.js"],"names":["path","require","chokidar","spawn","dependencyTree","ServerlessSDK","getAccessKeyForTenant","isEqual","findProcess","execOptions","env","process","SLS_DEV_MODE","stdio","slsCommand","module","exports","ctx","sls","deployToStage","USER","Math","floor","random","deployToRegion","persistStage","processedInput","options","stage","region","info","persist","endpoints","stdoutBuffer","toString","match","map","stringEndpoint","split","method","endpoint","e","stdout","write","JSON","stringify","meta","app","service","org","functions","resources","cli","log","processes","length","accessKey","sdk","platformStage","SERVERLESS_PLATFORM_STAGE","appState","isDeploying","isFunctionDeploying","connect","orgName","onEvent","event","data","clientType","isWebConnected","publishSync","updateAppState","publishAppState","isCliConnected","disconnect","cleanup","exit","filenameToFunctionsMapping","functionToFilenames","on","getServerlessInfo","filenameToFunctions","trackedFiles","output","parse","Object","keys","forEach","functionName","handler","dir","name","handlerEntry","join","list","toList","filename","directory","cwd","watchedFilename","funcs","Set","push","overrides","deploy","isRedeploying","rewatchFiles","watcher","unwatch","add","watch","filepath","endsWith","resolvedFilepath","normalize","sep","functionNames","Promise","all"],"mappings":"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","sourcesContent":["'use strict';\n\nconst path = require('path');\nconst chokidar = require('chokidar');\nconst spawn = require('child-process-ext/spawn');\nconst dependencyTree = require('dependency-tree');\nconst { ServerlessSDK } = require('@serverless/platform-client');\nconst { getAccessKeyForTenant } = require('@serverless/platform-sdk');\nconst { isEqual } = require('lodash');\nconst findProcess = require('find-process');\n\n/**\n * Pass along env variables, and also SLS_DEV_MODE which will capture logs for Serverless Studio\n */\nconst execOptions = {\n  env: {\n    ...process.env,\n    SLS_DEV_MODE: true,\n  },\n  stdio: 'inherit',\n};\n\nconst slsCommand = 'serverless';\n\nmodule.exports = async function(ctx) {\n  const { sls } = ctx;\n\n  /**\n   * Stage used for development. By default, pick a generated stage,\n   * unless specified by the user.\n   */\n  let deployToStage = `${process.env.USER || 'dev'}-${Math.floor(Math.random() * 100000)}`;\n  let deployToRegion = 'us-east-1';\n\n  /**\n   * If specified, do not remove the stage on exit\n   */\n  let persistStage = false;\n\n  const { stage, region, info, persist } = sls.processedInput.options;\n\n  if (stage) {\n    deployToStage = stage;\n  }\n\n  if (region) {\n    deployToRegion = region;\n  }\n\n  if (persist) {\n    persistStage = true;\n  }\n\n  /**\n   * Informational flag, used by parent watch process\n   */\n  if (info) {\n    let endpoints = [];\n\n    /**\n     * Close your eyes.\n     *\n     * Call 'serverless info' here to get the endpoints and pull them out of the output, if there are any.\n     */\n    try {\n      const { stdoutBuffer } = await spawn(slsCommand, [\n        'info',\n        `--stage=${deployToStage}`,\n        `--region=${deployToRegion}`,\n      ]);\n\n      endpoints = stdoutBuffer\n        .toString()\n        .match(/(ANY|GET|POST|PUT|PATCH|HEAD|OPTIONS|DELETE) - (.*)/g)\n        .map(stringEndpoint => {\n          const [method, endpoint] = stringEndpoint.split(' - ');\n\n          return {\n            method,\n            endpoint,\n          };\n        });\n    } catch (e) {\n      /**\n       * If we fail, it's probably because this this stage is not\n       * yet deployed.\n       */\n    }\n\n    /**\n     * Communicate relevant configuration settings to the parent process (sls dev):\n     *\n     *  - General app/org information\n     *  - Send new infra/functions to websocket\n     *  - Detect new functions to watch\n     */\n    process.stdout.write(\n      JSON.stringify({\n        meta: {\n          app: sls.service.app,\n          org: sls.service.org,\n          service: sls.service.service,\n          region: deployToRegion,\n          stage: deployToStage,\n        },\n        functions: sls.service.functions,\n        resources: sls.service.resources,\n        endpoints,\n      })\n    );\n\n    return;\n  }\n\n  sls.cli.log('Starting Serverless dev mode...');\n\n  /**\n   * As a pseudo-failsafe, don't support the prod stage to limit WebSocket traffic\n   */\n  if (deployToStage === 'prod') {\n    sls.cli.log(\"Stage 'prod' cannot be used with 'serverless dev'\");\n    return;\n  }\n\n  /**\n   * Check to see if 'serverless dev' is already running\n   */\n  const processes = await findProcess('name', /(serverless|sls) dev/g);\n\n  if (processes.length === 0) {\n    sls.cli.log('Failed to detect running serverless process. Exiting.');\n    return;\n  }\n\n  /**\n   * Only one process can be running\n   */\n  if (processes.length > 1) {\n    sls.cli.log(\"Only one instance of 'serverless dev' can be running\");\n    return;\n  }\n\n  const accessKey = await getAccessKeyForTenant(sls.service.org);\n\n  const sdk = new ServerlessSDK({\n    platformStage: process.env.SERVERLESS_PLATFORM_STAGE || 'prod',\n    accessKey,\n  });\n\n  /**\n   * Primary app state. This is communicated back-and-forth over the socket with the web\n   * client.\n   */\n  let appState = {\n    /**\n     * This is a 'sls deploy' (not a function deploy). It's required\n     * for the initial build, and also any changes to the the serverless.yml\n     * file\n     */\n    isDeploying: false,\n\n    /**\n     * Mapping of (function name) <String> -> <Boolean>\n     * to determine if a function is already deploying\n     */\n    isFunctionDeploying: {},\n\n    /**\n     * These are populated from the 'sls dev --info' output, which\n     * is a combination of a parsed serverless.yml, and outputs\n     * from 'serverless info' (namely the endpoints)\n     */\n    functions: {},\n    resources: {},\n    endpoints: [],\n  };\n\n  /**\n   * Connect to the WebSocket\n   */\n  await sdk.connect({\n    orgName: sls.service.org,\n    onEvent: async ({ event, data }) => {\n      const { clientType } = data;\n\n      if (event === 'studio.connect') {\n        /**\n         * If a web client connects to the socket, then send the appState. Also issue\n         * another 'studio.connect' to communicate the the CLI is in watch mode. This\n         * will handle a case where the web client refreshes.\n         */\n        if (clientType === 'web') {\n          appState.isWebConnected = true;\n          await sdk.publishSync({ event: 'studio.connect', data: { clientType: 'cli' } });\n          await updateAppState();\n          await publishAppState();\n        }\n\n        if (clientType === 'cli') {\n          appState.isCliConnected = true;\n        }\n      }\n    },\n  });\n\n  sls.cli.log('Connected to the Serverless Platform');\n\n  await sdk.publishSync({ event: 'studio.connect', data: { clientType: 'cli' } });\n\n  const disconnect = async () => {\n    await sdk.publishSync({ event: 'studio.disconnect', data: { clientType: 'cli' } });\n    await sdk.disconnect();\n\n    process.stdout.write('\\n');\n    sls.cli.log('Disconnected from the Serverless Platform');\n  };\n\n  const cleanup = async () => {\n    await disconnect();\n\n    /**\n     * Tear down the stage, unless specified otherwise\n     */\n    if (!persistStage) {\n      process.stdout.write('\\n');\n      sls.cli.log(`Cleaning up stage \"${deployToStage}\"...`);\n\n      await spawn(\n        slsCommand,\n        ['remove', `--stage=${deployToStage}`, `--region=${deployToRegion}`],\n        execOptions\n      );\n    }\n\n    process.exit(0);\n  };\n\n  let filenameToFunctionsMapping = {};\n  const functionToFilenames = {};\n\n  /**\n   * Capture ctrl+c and remove the stage that we setup\n   */\n  process.on('SIGINT', cleanup);\n  process.on('uncaughtException', disconnect);\n  process.on('exit', cleanup);\n\n  const getServerlessInfo = async () => {\n    const filenameToFunctions = {};\n    const trackedFiles = [];\n\n    /**\n     * Issue the --info variant of this command to get a parsed JSON output\n     * of the serverless.yml to determine HTTP endpoints\n     */\n    const { stdoutBuffer } = await spawn(\n      slsCommand,\n      ['dev', '--info', `--stage=${deployToStage}`],\n      {\n        env: process.env,\n      }\n    );\n\n    const output = JSON.parse(stdoutBuffer.toString());\n\n    const { functions } = output;\n\n    /**\n     * Use the handler path to reconstruct the path to the entry module\n     */\n    Object.keys(functions).forEach(functionName => {\n      const { dir, name } = path.parse(functions[functionName].handler);\n      const handlerEntry = `${path.join(dir, name)}.js`;\n\n      /**\n       * Determine modules required by the entry point of the handler\n       */\n      const list = dependencyTree.toList({\n        filename: handlerEntry,\n        directory: process.cwd(),\n      });\n\n      /**\n       * Store all files that make up this function\n       */\n      functionToFilenames[functionName] = list;\n\n      /**\n       * For convenience, map all watched modules to function(s)\n       */\n      list.forEach(watchedFilename => {\n        /**\n         * Functions already mapped to this file\n         */\n        const funcs = filenameToFunctions[watchedFilename] || [];\n\n        filenameToFunctions[watchedFilename] = new Set([...funcs, functionName]);\n      });\n\n      trackedFiles.push(...list);\n    });\n\n    return {\n      filenameToFunctions,\n      trackedFiles,\n      output,\n      functions,\n    };\n  };\n\n  const updateAppState = async () => {\n    const { output } = await getServerlessInfo();\n\n    appState = {\n      ...appState,\n      ...output,\n    };\n  };\n\n  /**\n   * Communicate application state to socket\n   */\n  const publishAppState = async overrides => {\n    await sdk.publishSync({\n      event: 'studio.state',\n      data: {\n        ...appState,\n        ...overrides,\n      },\n    });\n  };\n\n  /**\n   * Deploy the stack\n   */\n  const deploy = async isRedeploying => {\n    if (appState.isDeploying) {\n      return;\n    }\n\n    sls.cli.log(\n      `${\n        isRedeploying ? 'Redeploying' : 'Deploying'\n      } to stage \"${deployToStage}\". This may take a few minutes...`\n    );\n\n    appState.isDeploying = true;\n    await publishAppState();\n\n    await spawn(\n      slsCommand,\n      ['deploy', `--stage=${deployToStage}`, `--region=${deployToRegion}`],\n      execOptions\n    );\n\n    appState.isDeploying = false;\n    await updateAppState();\n    await publishAppState();\n  };\n\n  /**\n   * Communicate initial state of the serverless.yml\n   */\n  await updateAppState();\n  await publishAppState({\n    isDeploying: true,\n  });\n\n  /**\n   * Deploy the serverless.yml file\n   */\n  await deploy();\n\n  /**\n   * Compute new watch files. Only rewatch new files if parsing the serverless.yml file is successfull.\n   */\n  const rewatchFiles = async () => {\n    /**\n     * Compute new watch files. Only rewatch new files if parsing the serverless.yml file is successfull.\n     */\n    const { filenameToFunctions, trackedFiles } = await getServerlessInfo();\n\n    filenameToFunctionsMapping = filenameToFunctions;\n\n    /**\n     * Remove all paths\n     */\n    await watcher.unwatch('*');\n\n    /**\n     * Re-watch new files\n     */\n    watcher.add(['serverless.yml', ...trackedFiles]);\n  };\n\n  /**\n   * Create a new watcher. By default don't watch anything. The serverless.yml file\n   * will be parsed for function handlers. Those handlers will have their dependency\n   * trees mapped, and those files will be added dynamically by `rewatchFiles()`\n   */\n  const watcher = chokidar.watch([], {\n    /**\n     * Tracked files are absolute, and explicit. By default cwd is the currently working directory,\n     * which means the mapping between function and files will be wrong.\n     */\n    cwd: '/',\n  });\n\n  rewatchFiles();\n\n  sls.cli.log('Watching for changes...');\n\n  /**\n   * Watch for file changes\n   */\n  watcher.on('change', async filepath => {\n    const { isFunctionDeploying } = appState;\n\n    if (filepath.endsWith('serverless.yml')) {\n      /**\n       * Compare the function (names) in the serverless.yml file\n       * with what's already in the app state. We need to redeploy\n       * the stack if:\n       *\n       *  1. A new function has ben added\n       *  2. A function has been renamed\n       *  3. If you change settings of a function\n       */\n      const { functions } = await getServerlessInfo();\n\n      if (!isEqual(functions, appState.functions)) {\n        sls.cli.log('serverless.yml functions changed');\n        await deploy(true);\n\n        await updateAppState();\n        await publishAppState();\n\n        rewatchFiles();\n      }\n\n      return;\n    }\n\n    /**\n     * Force resolved file path to be absolute.\n     */\n    const resolvedFilepath = path.normalize(`${path.sep}${filepath}`);\n    const functionNames = filenameToFunctionsMapping[resolvedFilepath];\n\n    if (!functionNames) {\n      return;\n    }\n\n    /**\n     * Redeploy all changed functions\n     */\n    await Promise.all(\n      [...functionNames].map(async functionName => {\n        if (isFunctionDeploying[functionName]) {\n          return;\n        }\n\n        sls.cli.log(`${functionName}: changed. Redeploying...`);\n\n        isFunctionDeploying[functionName] = true;\n\n        /**\n         * Redeploy the function\n         */\n        try {\n          await spawn(\n            slsCommand,\n            ['deploy', 'function', `--function=${functionName}`, `--stage=${deployToStage}`],\n            execOptions\n          );\n        } catch (e) {\n          /**\n           * This ocassionally fails, although I haven't yet been able\n           * to track down why.\n           */\n        } finally {\n          isFunctionDeploying[functionName] = false;\n        }\n      })\n    );\n  });\n};\n"],"file":"dev.js"}