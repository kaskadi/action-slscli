"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var crypto_1 = tslib_1.__importDefault(require("crypto"));
var moment_1 = tslib_1.__importDefault(require("moment"));
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var querystring_1 = tslib_1.__importDefault(require("querystring"));
function logger(topic, content) {
    console.log(chalk_1.default.black.bgYellow('[DEBUG]') + " " + chalk_1.default.green(topic + ":") + " " + content + " ");
}
exports.logger = logger;
function getHost(_a, isV1) {
    var host = _a.host, ServiceType = _a.ServiceType, Region = _a.Region, baseHost = _a.baseHost;
    if (isV1 === void 0) { isV1 = false; }
    if (!host) {
        host = "" + ServiceType + (isV1 ? '' : "." + Region) + "." + baseHost;
    }
    return host;
}
exports.getHost = getHost;
function getUrl(opts, isV1) {
    if (isV1 === void 0) { isV1 = false; }
    opts = opts || {};
    var host = getHost(opts, isV1);
    var path = opts.path || '/';
    return (opts.protocol || 'https') + "://" + host + path;
}
exports.getUrl = getUrl;
function sign(str, secretKey, algorithm) {
    if (algorithm === void 0) { algorithm = 'sha256'; }
    var hmac = crypto_1.default.createHmac(algorithm, secretKey);
    return hmac.update(Buffer.from(str, 'utf8')).digest();
}
exports.sign = sign;
/**
 * is array
 * @param obj object
 */
function isArray(obj) {
    return Object.prototype.toString.call(obj) == '[object Array]';
}
exports.isArray = isArray;
/**
 * is object
 * @param obj object
 */
function isObject(obj) {
    return obj === Object(obj);
}
exports.isObject = isObject;
/**
 * iterate object or array
 * @param obj object or array
 * @param iterator iterator function
 */
function _forEach(obj, iterator) {
    if (isArray(obj)) {
        var arr = obj;
        if (arr.forEach) {
            arr.forEach(iterator);
            return;
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    }
    else {
        var oo = obj;
        for (var key in oo) {
            if (obj.hasOwnProperty(key)) {
                iterator(oo[key], key, obj);
            }
        }
    }
}
exports._forEach = _forEach;
/**
 * flatter request parameter
 * @param obj target object or array
 */
function flatten(obj) {
    if (!isArray(obj) && !isObject(obj)) {
        return {};
    }
    var ret = {};
    var _dump = function (obj, prefix, parents) {
        var checkedParents = [];
        if (parents) {
            var i = void 0;
            for (i = 0; i < parents.length; i++) {
                if (parents[i] === obj) {
                    throw new Error('object has circular references');
                }
                checkedParents.push(obj);
            }
        }
        checkedParents.push(obj);
        if (!isArray(obj) && !isObject(obj)) {
            if (!prefix) {
                throw obj + 'is not object or array';
            }
            ret[prefix] = obj;
            return {};
        }
        if (isArray(obj)) {
            // it's an array
            _forEach(obj, function (obj, i) {
                _dump(obj, prefix ? prefix + '.' + i : '' + i, checkedParents);
            });
        }
        else {
            // it's an object
            _forEach(obj, function (obj, key) {
                _dump(obj, prefix ? prefix + '.' + key : '' + key, checkedParents);
            });
        }
    };
    _dump(obj, null);
    return ret;
}
exports.flatten = flatten;
/**
 * generate tencent cloud sign result
 *
 * @param {Payload} payload
 * @param {CapiOptions} options
 * @returns {TencentSignResult}
 */
function tencentSign(payload, options) {
    var hostParams = {
        host: options.host,
        path: options.path,
        protocol: options.protocol,
        baseHost: options.baseHost,
        ServiceType: options.ServiceType,
        Region: options.Region,
    };
    var url = getUrl(hostParams);
    var Host = getHost(hostParams);
    var nowTime = moment_1.default();
    var Timestamp = nowTime.unix();
    // const Nonce = Math.round(Math.random() * 65535)
    var date = nowTime.toISOString().slice(0, 10);
    var Algorithm = 'TC3-HMAC-SHA256';
    payload.RequestClient = payload.RequestClient || 'TENCENT_SDK_CAPI';
    payload = flatten(payload);
    // 1. create Canonical request string
    var HTTPRequestMethod = (options.method || 'POST').toUpperCase();
    var CanonicalURI = '/';
    var CanonicalQueryString = '';
    var CanonicalHeaders = "content-type:application/json\nhost:" + Host + "\n";
    var SignedHeaders = 'content-type;host';
    var HashedRequestPayload = crypto_1.default
        .createHash('sha256')
        .update(JSON.stringify(payload))
        .digest('hex');
    var CanonicalRequest = HTTPRequestMethod + "\n" + CanonicalURI + "\n" + CanonicalQueryString + "\n" + CanonicalHeaders + "\n" + SignedHeaders + "\n" + HashedRequestPayload;
    // 2. create string to sign
    var CredentialScope = date + "/" + options.ServiceType + "/tc3_request";
    var HashedCanonicalRequest = crypto_1.default
        .createHash('sha256')
        .update(CanonicalRequest)
        .digest('hex');
    var StringToSign = Algorithm + "\n" + Timestamp + "\n" + CredentialScope + "\n" + HashedCanonicalRequest;
    // 3. calculate signature
    var SecretDate = sign(date, Buffer.from("TC3" + options.SecretKey, 'utf8'));
    var SecretService = sign(options.ServiceType, SecretDate);
    var SecretSigning = sign('tc3_request', SecretService);
    var Signature = crypto_1.default
        .createHmac('sha256', SecretSigning)
        .update(Buffer.from(StringToSign, 'utf8'))
        .digest('hex');
    // 4. create authorization
    var Authorization = Algorithm + " Credential=" + options.SecretId + "/" + CredentialScope + ", SignedHeaders=" + SignedHeaders + ", Signature=" + Signature;
    // log debug info
    if (options.debug) {
        logger('CanonicalRequest', CanonicalRequest);
        logger('StringToSign', StringToSign);
        logger('Signature', Signature);
        logger('Authorization', Authorization);
    }
    return {
        url: url,
        payload: payload,
        Host: Host,
        Authorization: Authorization,
        Timestamp: Timestamp,
    };
}
exports.tencentSign = tencentSign;
/**
 * version1: generate tencent cloud sign result
 *
 * @param {Payload} payload
 * @param {CapiOptions} options
 * @returns {TencentSignResultV1}
 */
function tencentSignV1(payload, options) {
    var hostParams = {
        host: options.host,
        path: options.path,
        protocol: options.protocol,
        baseHost: options.baseHost,
        ServiceType: options.ServiceType,
        Region: options.Region,
    };
    var url = getUrl(hostParams, true);
    var Host = getHost(hostParams, true);
    var nowTime = moment_1.default();
    var Timestamp = nowTime.unix();
    var Nonce = Math.round(Math.random() * 65535);
    payload.Region = options.Region;
    payload.Nonce = Nonce;
    payload.Timestamp = Timestamp;
    payload.SecretId = options.SecretId;
    payload.RequestClient = payload.RequestClient || 'SDK_NODEJS_v0.0.1';
    if (options.SignatureMethod === 'sha256') {
        payload.SignatureMethod = 'HmacSHA256';
    }
    payload = flatten(payload);
    var keys = Object.keys(payload).sort();
    var method = (options.method || 'POST').toUpperCase();
    var qstr = '';
    keys.forEach(function (key) {
        if (key === '') {
            return;
        }
        key = key.indexOf('_') ? key.replace(/_/g, '.') : key;
        var val = payload[key];
        if (method === 'POST' && val && val[0] === '@') {
            return;
        }
        if (val === undefined ||
            val === null ||
            (typeof val === 'number' && isNaN(val))) {
            val = '';
        }
        qstr += "&" + key + "=" + val;
    });
    qstr = qstr.slice(1);
    payload.Signature = sign("" + method + Host + options.path + "?" + qstr, Buffer.from(options.SecretKey, 'utf8'), options.SignatureMethod).toString('base64');
    return {
        url: url,
        method: method,
        signPath: querystring_1.default.stringify(payload),
    };
}
exports.tencentSignV1 = tencentSignV1;
//# sourceMappingURL=utils.js.map